/*
 * Author: Ronan Richardson
 * Date: 29/10/2021
 * Folder Location: Assets/Scripts/Audio
 */

using System;
using UnityEngine;
using UnityEngine.Audio;

// Disable the "never assigned to, default value of null" warning as it is bugged (all members are assigned a value)
#pragma warning disable 0649

/// <summary>
/// <para>
/// Sound is a wrapper class that extends the functionality for an Audio Source as a scriptable object, converting 
/// each sound into an asset that is easily customisable prior to runtime in the asset inspector. The Sound class
/// contains 9 member variables that are direct analogues to their corresponding Audio Source variables, each with properties
/// that simply set the corresponding audio source variable whenever a sound variable is set. The class contains two functions
/// called Init() which are used to initialise a Sound object, the first is called on Sound objects that have been created and
/// set up as assets prior to runtime, and the second is called on Sound objects that are generated for audio clips that are
/// missing corresponding Sound objects at runtime. The class also contains the functions Play(), PlayOneShot() and Stop() which
/// each just call the corresponding Audio Source function.
/// </para>
/// <b>Important: When creating Sound objects in the asset menu, please make sure they are stored in Assets/Resources/Audio/Sounds.</b>
/// </summary>
[CreateAssetMenu(fileName = "Sound", menuName = "Scriptable Objects/Sound")]
public class Sound : ScriptableObject
{
    // The properties relating to each audio source equivalent simply set the corresponding audio source variable whenever it's sound equivalent is set
    #region Audio Source Wrapper Variables

    public AudioClip m_audioClip;
    [SerializeField] private AudioMixerGroup m_audioMixerGroup;
    private AudioSource m_audioSource;

    [SerializeField] private bool m_mute;
    public bool Mute
    {
        get { return m_mute; }
        set { m_audioSource.mute = m_mute = value; }
    }

    [SerializeField] private bool m_playOnAwake;
    public bool PlayOnAwake
    {
        get { return m_playOnAwake; }
        set { m_audioSource.playOnAwake = m_playOnAwake = value; }
    }

    [SerializeField] private bool m_loop;
    public bool Loop
    {
        get { return m_loop; }
        set { m_audioSource.loop = m_loop = value; }
    }

    [SerializeField] [Range(0, 256)] private int m_priority = 128;
    public int Priority
    {
        get { return m_priority; }
        set { m_audioSource.priority = m_priority = value; }
    }

    [SerializeField] [Range(0, 1)] private float m_volume;
    public float Volume
    {
        get { return m_volume; }
        set { m_audioSource.volume = m_volume = value; }
    }

    [SerializeField] [Range(-3, 3)] private float m_pitch;
    public float Pitch
    {
        get { return m_pitch; }
        set { m_audioSource.pitch = m_pitch = value; }
    }

    public bool IsPlaying
    {
        get { return m_audioSource.isPlaying; }
    }

    #endregion

    /// <summary>
    /// OnValidate() is an editor only function that is called whenever a value is changed in the Sound editor.
    /// It is used to update the audio source variables during runtime in editor mode.
    /// </summary>
    private void OnValidate()
    {
        if (m_audioSource)
        {
            UpdateAudioSource();
        }
    }

    /// <summary>
    /// Init() takes an input of the pre-generated Audio Source for this sound to play it's audio clip with,
    /// and sets all of the relevant Audio Source parameters using their corresponding Sound wrapper parameters.
    /// The Audio Source is generated by the Sound Manager class OnAwake() when collating all sounds in the game.
    /// This version of Init() is called on Sound objects that have already been pre-created and customised
    /// as assets prior to runtime.
    /// </summary>
    /// <param name="source">The Audio Source clone that this sound should use to play clips.</param>
    public void Init(AudioSource source)
    {
        // Make sure the audio source has been correctly passed to this function, and that audio clip and audio mixer group have been set in the inspector for this sound
        if (source == null)
        {
            throw new ArgumentNullException("Audio Source for the " + name + " Sound has been passed incorrectly, please re-check the callstack.");
        }
        if (m_audioClip == null)
        {
            throw new ArgumentNullException("Audio Clip for the " + name + " Sound is missing! Please attach it in the inspector.");
        }
        if (m_audioMixerGroup == null)
        {
            throw new ArgumentNullException("Audio Mixer Group for the " + name + " Sound is missing! Please attach it in the inspector.");
        }

        m_audioSource = source;
        m_audioSource.gameObject.name = m_audioClip.name;
        // Initialise the audio source wrapper variables to whatever they've been set to in the inspector
        UpdateAudioSource();

        // If playOnAwake is true, trigger the audio source here because it won't trigger on awake otherwise
        if (m_playOnAwake)
        {
            m_audioSource.Play();
        }
    }

    /// <summary>
    /// Init() takes an input of the pre-generated Audio Source for this sound to play it's audio clip with,
    /// the SFX audio mixer group to play through, and the audio clip to associate to this sound, and initalises 
    /// all of the relevant sound parameters (and their corresponding audio source parameters) to their default 
    /// values. This is because this version of Init() is only called on Sound objects that are generated for 
    /// audio clips at runtime, and therefore have not had any of their parameters customised by anyone in the 
    /// inpsector prior to runtime. The Audio Source is generated by the Sound Manager class when collating all 
    /// sounds in the game.
    /// </summary>
    /// <param name="source">The Audio Source clone that this sound should use to play clips.</param>
    /// <param name="clip">The Audio Clip to associate to this sound.</param>
    public void Init(AudioSource source, AudioClip clip, AudioMixerGroup audioMixerGroup)
    {
        // Make sure both the audio source and audio clip have been correctly passed as parameters
        if (clip == null)
        {
            throw new ArgumentNullException("Audio Clip has been passed incorrectly, please re-check the callstack.");
        }
        if (source == null)
        {
            throw new ArgumentNullException("Audio Source for the " + (name = m_audioClip.name) + " Sound has been passed incorrectly, please re-check the callstack.");
        }

        m_audioSource = source;
        m_audioClip = clip;
        m_audioSource.gameObject.name = m_audioClip.name;

        // Initialise the audio source wrapper variables to their default values as they have not been pre-set in the inspector, then use them to set the corresponding audio source variables
        m_audioSource.clip = m_audioClip;
        m_audioSource.outputAudioMixerGroup = audioMixerGroup;
        m_audioSource.mute = m_mute = false;
        m_audioSource.playOnAwake = m_playOnAwake = false;
        m_audioSource.loop = m_loop = false;
        m_audioSource.priority = m_priority = 128;
        m_audioSource.volume = m_volume = 0.1f;
        m_audioSource.pitch = m_pitch = 1;
    }

    /// <summary>
    /// Play() is an accessor function that simply calls Play() on the private audio source of this sound.
    /// </summary>
    public void Play()
    {
        if (!m_audioSource.isPlaying)
        {
            m_audioSource.Play();
        }
    }

    /// <summary>
    /// PlayOneShot() is an accessor function that simply calls PlayOneShot() on the private audio source of this sound
    /// with its associated audio clip.
    /// </summary>
    public void PlayOneShot()
    {
        if (!m_audioSource.isPlaying)
        {
            m_audioSource.PlayOneShot(m_audioClip);
        }
    }

    /// <summary>
    /// Stop() is an accessor function that simply calls Stop() on the private audio source of this sound.
    /// </summary>
    public void Stop()
    {
        if (m_audioSource.isPlaying)
        {
            m_audioSource.Stop();
        }
    }

    /// <summary>
    /// UpdateAudioSource() simply updates all of the audio source variables by setting
    /// them with their corresponding sound wrapper variables stored in this class.
    /// </summary>
    private void UpdateAudioSource()
    {
        m_audioSource.clip = m_audioClip;
        m_audioSource.outputAudioMixerGroup = m_audioMixerGroup;
        m_audioSource.mute = m_mute;
        m_audioSource.playOnAwake = m_playOnAwake;
        m_audioSource.loop = m_loop;
        m_audioSource.priority = m_priority;
        m_audioSource.volume = m_volume;
        m_audioSource.pitch = m_pitch;
    }
}